import numpy as np
import torch
from torch.utils.data import Dataset, DataLoader
import h5py
import json
from sklearn.preprocessing import StandardScaler


class MetrLaDataset(Dataset):
    def __init__(self, h5_file, edge_index_file, event_triplet_file,
                 entity2id, relation2id, seq_len=12, pred_len=3, split='train'):
        """
        h5_file: METR-LA traffic data
        edge_index_file: adjacency info
        event_triplet_file: knowledge triples
        """
        with h5py.File(h5_file, 'r') as f:
            self.data = f['df'][:].astype(np.float32)  # shape (T, N)
        self.num_nodes = self.data.shape[1]

        # Normalize
        self.scaler = StandardScaler()
        self.data = self.scaler.fit_transform(self.data)

        self.seq_len = seq_len
        self.pred_len = pred_len

        # Data split
        T = self.data.shape[0]
        train_end = int(T * 0.7)
        val_end = int(T * 0.9)
        if split == 'train':
            self.indices = range(0, train_end - seq_len - pred_len)
        elif split == 'val':
            self.indices = range(train_end, val_end - seq_len - pred_len)
        else:
            self.indices = range(val_end, T - seq_len - pred_len)

        # Load graph edges
        self.edge_index = torch.LongTensor(np.load(edge_index_file))

        # Load event triples
        with open(event_triplet_file, 'r') as f:
            self.event_data = json.load(f)

        self.entity2id = entity2id
        self.relation2id = relation2id

    def __len__(self):
        return len(self.indices)

    def encode_event_triplets(self, triplets):
        """
        Convert triplets to ID format
        """
        encoded = []
        for h, r, t in triplets:
            h_id = self.entity2id.get(h, 0)
            r_id = self.relation2id.get(r, 0)
            t_id = self.entity2id.get(t, 0)
            encoded.append((h_id, r_id, t_id))
        return encoded

    def __getitem__(self, idx):
        i = self.indices[idx]
        seq_x = self.data[i:i+self.seq_len]  # (seq_len, num_nodes)
        seq_y = self.data[i+self.seq_len:i+self.seq_len+self.pred_len]  # (pred_len, num_nodes)

        # Get associated event triplets
        event_triplets = self.event_data.get(str(i), [])
        encoded_triplets = self.encode_event_triplets(event_triplets)

        return (
            torch.FloatTensor(seq_x),
            torch.FloatTensor(seq_y),
            torch.LongTensor(encoded_triplets),
            self.edge_index
        )
